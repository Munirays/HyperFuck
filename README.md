# HyperFuck 语言

注：HyperFuck是**esolang**类语言。

### 虚拟机

HyperFuck与BrainFuck**在外观上**相似，不同的是，HyperFuck类似于简化过的汇编语言

HyperFuck的虚拟机只包括**储存器**、8个**数据寄存器**（qwertyui）、4个**指针寄存器**（asdf）此处的指针寄存器直接记录地址、一个**跳跃寄存器**（/）用于临时保存内存地址 和一个**结果寄存器**（?）用于返回值。  

HyperFuck允许代码内出现空白或换行。注释必须在新的一行，且以 # 开头。

### 语法

#### 1. 寄存器

HyperFuck中的寄存器只能**加1减1**、**自增自减**或**加减别的寄存器数据**。  

操作一个寄存器，需要先**选中**，选中的寄存器看作**目标寄存器**；然后输入操作符，后接0个或多个其他寄存器；最后提到的寄存器看作**最后选中的寄存器**。  

| 字符                  | 说明               |
| --------------------- | ------------------ |
| q、w、e ... j、k      | 选中寄存器         |
| ^                     | 加1                |
| v                     | 减1                |
| （寄存器）+（寄存器） | 加上别的寄存器数据 |
| （寄存器）-（寄存器） | 减去别的寄存器数据 |
| （寄存器）~（寄存器） | 传送寄存器数据     |

**示例：**

```
q^^w~q^^
```

这段代码首先选中了q寄存器，加2，此时q寄存器为2；选中w寄存器，将q的数据传送到w，此时q和w都为2；因为q是最后提到的寄存器，因此现在选中的寄存器仍是q，将q加2，此时q为4，w为2。

#### 2. 堆栈与内存

HyperFuck的堆栈不能直接操作，必须移到寄存器中操作。

| 字符 | 说明 |
| ---- | ---- |
| ]    | 入栈 |
| [    | 出栈 |

执行内存存放HyperFuck的源代码，可以通过指针跳到某处执行。   

允许的字符有：zxcbnm；字符可以重复，后者会覆盖前者。  

| 字符      | 说明                                       |
| --------- | ------------------------------------------ |
| （字符）' | 记录此处的执行内存地址                     |
| （字符）, | 跳到该内存地址执行                         |
| {}        | 定义语句块，只有在要求跳跃时执行；不能嵌套 |
| *         | 取消忽略跳跃指令                           |

跳跃指令执行完毕后**不会自动跳回来**。 

**示例**

```
z'{*q]q^^?~q[/[,}
q^^a']z,*q+?
```

此处的z记录了：恢复跳跃指令，将q压入栈，将q加2，将q传送到**结果寄存器**，再弹出栈到q，将之前压入栈的内存地址取出并跳转。  

主程序：将q加2，记录当前内存地址并压入栈，跳转到z，恢复跳跃指令，将q加上返回的结果。最终，q为4。  

#### 3. 输入输出

| 字符 | 说明                                   |
| ---- | -------------------------------------- |
| .    | 输出寄存器的数字对应的ASCII            |
| @    | 从键盘读取字符，转换为数字储存到寄存器 |
| \    | 换行                                   |

#### 4. 逻辑

所有的逻辑运算都将结果保存到**结果寄存器**。  

| 字符 | 说明     |
| ---- | -------- |
| <    | 是否小于 |
| >    | 是否大于 |
| =    | 是否等于 |
| !    | 取反     |
| &    | 与运算   |
| \|   | 或运算   |

使用 `寄存器( ... )` 来循环，循环直到寄存器的值为1。

**示例**

```
q^^w^
=q?!~i(e^^iv)
```

这段代码的意思是：将q增加2，将a增加1。如果q不等于a，就将e增加2。由于 `=` 运算结果只可能为0或1，取反后仍为0或1，所以如果结果为1，只需要减去1，就能让结果变为0。

### 其他语言

由于HyperFuck语言的解释器用Python编写，因此暂时只能调用Python函数。

在解释HyperFuck时增加参数 `-i （文件名.hi）` 可以让HyperFuck引用Python。   

`.hi` 文件的格式形似：

```
random.py randint,randascii
foo.py bar
```

每一行是一个文件，空格后接要引用的函数名。

函数参数必须为 `dict` （寄存器数据字典）和 `list` （栈），可直接对其操作。

